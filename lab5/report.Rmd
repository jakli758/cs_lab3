# Question 2
#### a)
```{r, include=FALSE, echo = FALSE, message=FALSE, warning=FALSE}
library(latex2exp)
library(ggplot2)
```

In the task statement we are instructed to assume a $\beta$ value of $1$, therefore 
effectively eliminating and thus simplifying our calculations. 

In the code block below you can see two functions implemented. 
`inverse_transformation` takes a value $u$ as input and applies the *inverse of the cumulative 
density function* of a gumbel distribution with a location parameter $\mu$. 

The `sample_gumbel` function samples $n$ random variables from the distribution $U \sim Uniform(0,1)$
(the range of values a *CDF* puts out) and then applies the `inverse_transformation` on them.
This is equal to $n$ random variables sampled from a gumbel distribution with the aforementioned location parameter $\mu$. 

```{r}
n <- 13

inverse_transformation <- function(u, mu){
  c <- log(log(2))
  x <- mu + c -log(-log(u))
  return(x)
}

sample_gumbel <- function(n, mu){
  uniform_rvs <- runif(n, 0, 1)
  gumbel_rvs <- sapply(uniform_rvs, inverse_transformation, mu=mu)
  return(gumbel_rvs)
}

gumbel_rvs <- sample_gumbel(n, 0) # Sample random gumbel variables
```

#### b) 
Instead of relying on the implementation in the `BDSA`package, we decided to implement our own sign test. 

This consists of a function called `hypothesis_test`, which performs a *hypothesis test* given a sample of random gumbel variables, and tests whether the *location parameter* / $\mu$ of the distribution these variables are sampled from is different from $0$. 

We then extract the *p-values* from these tests and return them. The `sign_test` function produces $1000$ random samples of size $n$ from a gumbel distribution with *location parameter* $\mu$. It then computes the previously mentioned hypothesis test and affiliated p-values. Given a significance level $\alpha$, it then computes the fraction of hypothesis tests, which are below the significance level. This fraction is the *power* of the *sign test* for a given value for $\mu$. We then repeat this procedure for $100$ different $\mu$ values in the interval $[0,2]$ and plot the associated power values.

We chose to repeat the sign test a $1000$ times, as we rely on the *Law of Large Numbers* to ensure that our estimate for the power of the test. In statistics the minimum power for a test to be viable is typically set at $\hat p = 0.8$. At such a power level, the *standard error* ($SE$) of our estimate would be $SE = \frac{\hat p(1-\hat p)}{n} = \frac{0.8\cdot0.2}{1000}\approx0.0126$. 
```{r}
hypothesis_test <- function(gumbel_rvs){
  x <- sum(ifelse(gumbel_rvs > 0, 1, 0))
  result <- binom.test(x, length(gumbel_rvs), p = 0.5, alternative = "greater")
  return(result$p.value)
}

sign_test <- function(n, mu, alpha){
  rvs <- lapply(1:1000, function(i) sample_gumbel(n = n, mu = mu))
  p_values <- sapply(rvs, hypothesis_test)
  power <- mean(ifelse(p_values <= alpha, 1, 0))
  return(power)
}
```
```{r, echo=FALSE}
n <- 13
alpha <- 0.05
mus <- seq(0, 2, by = 0.02)
result_list <- lapply(mus, function(mu) sign_test(n = n, mu = mu, alpha = alpha))
plot(x = mus, y = result_list, type = "b", xlab = TeX("$\\mu$ values"), ylab = "Power values", col = "blue", 
     main = TeX("Sign power values for gimbel distributions with varying $\\mu$"))
```
# Appendix
```{r}
library(latex2exp)
library(ggplot2)

#' Function for performing an inverse gumbel transformation
#' 
#' @param u Random variable sampled from uniform distribution U~(0,1). Value we 
#' are applying the inverse gumbel cdf on.
#' @param mu Mean of the gumbel distribution also known as location parameter
#' @returns gumble-distributed random variable

inverse_transformation <- function(u, mu){
  c <- log(log(2))
  x <- mu + c -log(-log(u))
  return(x)
}

#' Function for sampling random variables from a gumbel distribution 
#' @param n number of sampled random variables
#' @param mu location parameter (median) of gumbel distribution
#' @returns vector of n random variables from gumbel distribution with mu as median
sample_gumbel <- function(n, mu){
  uniform_rvs <- runif(n, 0, 1)
  gumbel_rvs <- sapply(uniform_rvs, inverse_transformation, mu=mu)
  return(gumbel_rvs)
}

#' Function for performing hypothesis test given a list of random variables
#' (Tests if the median of the distribution is not 0)
#' @param gumbel_rvs vector of random variables
#' @returns p-value of test
hypothesis_test <- function(gumbel_rvs){
  x <- sum(ifelse(gumbel_rvs > 0, 1, 0))
  result <- binom.test(x, length(gumbel_rvs), p = 0.5, alternative = "greater")
  return(result$p.value)
}

#'Function for performing sign test given.
#'@param n number of samples to feature
#'@param mu location parameter of gimbel distribution for which we test
#'@param alpha significance level we use in the hypothesis test
#'@returns power value of sign_test
sign_test <- function(n, mu, alpha){
  rvs <- lapply(1:1000, function(i) sample_gumbel(n = n, mu = mu))
  p_values <- sapply(rvs, hypothesis_test)
  power <- mean(ifelse(p_values <= alpha, 1, 0))
  return(power)
}

n <- 13
alpha <- 0.05
mus <- seq(0, 2, by = 0.02)
result_list <- lapply(mus, function(mu) sign_test(n = n, mu = mu, alpha = alpha))
plot(x = mus, y = result_list, type = "b", xlab = TeX("$\\mu$ values"), ylab = "Power values", col = "blue", 
     main = TeX("Sign power values for gimbel distributions with varying $\\mu$"))
```