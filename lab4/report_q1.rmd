## Question 1:

$$
f(x)=120x^5e^{-x}, x>0
$$

The target function has the following shape:

```{r echo=FALSE}
f <- function(x){
  if (x > 0){
    return (120*x^5*exp(-x))
  }
  else{
    stop("Function undefined for x <= 0.")
  }
}
x <- seq(1,10,0.01)
x_app <- sapply(x,f)
plot(x, x_app, main = "Target function")
```


#### a. Use the Metropolis–Hastings algorithm to generate 10000 samples $X_t$, t = 1, . . . , 10000, from this distribution. Use a normal distribution with mean $X_t$ and standard deviation 0.1 as proposal distribution when you generate $X_{t+1}$; take some starting point. Plot the chain you obtained with iterations on the horizontal axis. What can you guess about the convergence of the chain? If there is a burn–in period, what can be the size of this period? What is the acceptance rate? Plot a histogram of the sample.


```{r}
set.seed(42)

metropolis_normal <- function(n_iter = 10000, start = 1, proposal_sd = 0.1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rnorm(1, mean = x[t - 1], sd = proposal_sd)
    
    # f undefined for x <= 0
    if (proposal > 0) { 
      rate <- min(1, f(proposal) / f(x[t - 1]))
      if (runif(1) < rate) {
        x[t] <- proposal
        accept <- accept + 1
      } else {
        x[t] <- x[t - 1]
      }
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  return(list(chain = x, acceptance_rate = accept / n_iter))
}
```

 

```{r echo=FALSE}
result_a <- metropolis_normal(n_iter=10000)
samples_a <- result_a$chain
acceptance_rate_a <- result_a$acceptance_rate
plot(samples_a, type = "l", main = "Trace Plot (Part a)", xlab = "Iteration", ylab = "X_t")
hist(samples_a, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part a)", xlab = "X_t")
```

- The generated sequence converges to the target distribution, if it is irreducible and aperiodic. Irreducibility is given by the fact that for the normal distribution every $X_t$ has a non-zero probability to be reached from every other positive value. It is also aperiodic as the proposal distribution does not have a fixed cycle. Hence, we can say, that the sequence converges.

- According to the trace plot the chain seems too have a very long burn-in period, as it is not really fluctuating around a value. This would explain why the histogram of the samples has no similarity with the shape of the target distributions. Getting a bigger sequence with 50,000 samples instead confirms that the sequence converges. The burn-in period seems to be around 15000 iterations:  

```{r echo=FALSE}
result_a <- metropolis_normal(n_iter=50000)
samples_a <- result_a$chain
acceptance_rate_a <- result_a$acceptance_rate
plot(samples_a, type = "l", main = "Trace Plot (Part a)", xlab = "Iteration", ylab = "X_t")
hist(samples_a, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part a)", xlab = "X_t")
```

- The acceptance rate is very high: `0.9835`.

#### b. Perform part a. by using the chi-square distribution as a proposal distribution.


```{r}
metropolis_chisq <- function(n_iter = 10000, start = 1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rchisq(1, floor(x[t - 1] + 1))
    rate <- min(1, f(proposal) / f(x[t - 1]))
    if (runif(1) < rate) {
      x[t] <- proposal
      accept <- accept + 1
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  list(samples = x, acceptance_rate = accept / n_iter)
}
```

```{r echo=FALSE}
# Run the algorithm
result_b <- metropolis_chisq()
samples_b <- result_b$samples
acceptance_rate_b <- result_b$acceptance_rate

# Plot the chain and histogram
plot(samples_b, type = "l", main = "Trace Plot (Part b)", xlab = "Iteration", ylab = "X_t")
hist(samples_b, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part b)", xlab = "X_t")
```

- According to the definition the sequence should converge again. The shape of the histogram confirms this assumption.

- For this proposal distribution the burn-in period is significantly shorter and can't really be derived from the trace plot.

- The acceptance rate is `0.6047`




#### c. Suggest another proposal distribution (can be a normal or chi–square distribution with other parameters or another distribution) with the potential to generate a good sample. Perform part a with this distribution.

 
For this sequence we choose a gamma distribution with $\alpha = 3$ and $\beta = 1$:

```{r}

metropolis_gamma <- function(n_iter = 10000, start = 1, alpha = 3, beta = 1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rgamma(1, shape = alpha, rate = beta)
    rate <- min(1, f(proposal) / f(x[t - 1]))
    if (runif(1) < rate) {
      x[t] <- proposal
      accept <- accept + 1
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  list(samples = x, acceptance_rate = accept / n_iter)
}

```

```{r}
result_c <- metropolis_gamma()
samples_c <- result_c$samples
acceptance_rate_c <- result_c$acceptance_rate

plot(samples_c, type = "l", main = "Trace Plot (Part c)", xlab = "Iteration", ylab = "X_t")
hist(samples_c, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part c)", xlab = "X_t")
```

- We expect the sequence to converge again using a gamma  distribution as proposal distribution, according to the definition.

- The results are very similar to the ones from part b. The shape of the histogram follows the target distribution and the trace plot indicates a very short burn-in rate. 

- With `0.5699` the acceptance rate is even a bit lower.


#### d. Compare the results of parts a, b and c and make conclusions.


Sequences from the target distribution can be sampled with all three proposal distributions. Using the normal distribution requires significantly more iterations and a high burn-in period. It also has a very high acceptance rate, which makes it suboptimal as a proposal distribution. 

The results for the other two proposal distributions are very similar. Though the histogram resulting from using the gamma distribution seems to fit even a bit better and it also has the lower acceptance rate that is closer to the ideal 0.44 for the unidimensional case.

Therefore, the gamma distribution would be our choice for the proposal distribution. 

#### e. Estimate the expected value using samples from parts a, b and c.


```{r echo=FALSE}
estimate_expectation <- function(samples) {
  mean(samples)
}

cat("Estimated E(X) (Part a):", estimate_expectation(samples_a), "\n")
cat("Estimated E(X) (Part b):", estimate_expectation(samples_b), "\n")
cat("Estimated E(X) (Part c):", estimate_expectation(samples_c), "\n")

```

#### f. The distribution generated is in fact a gamma distribution. Search in the literature/internet and define the actual value of the integral. Compare it with the one you obtained.

Source for this task: https://en.wikipedia.org/wiki/Gamma_distribution

The general PDF for the gamma distribution is the following: 

$$
\frac{\beta^{\alpha}} {\Gamma(\alpha)} x^{\alpha-1}  e^{-\beta x}
$$

Matching this to the target function $f(x)$ we can derive that $\alpha = 5 + 1 = 6$ and $\beta = 1$.  With the result $\Gamma(6) = (6-1)! = 120$ we get the required form.  

The expected value of a gamma distribution is defined as $\frac{\alpha}{\beta}$. Therefore $E(X)=\frac{6}{1}=6$. Contrary to expectations, the mean from part a is the closest.


## Appendix

```{r eval=FALSE}
f <- function(x){
  if (x > 0){
    return (120*x^5*exp(-x))
  }
  else{
    stop("Function undefined for x <= 0.")
  }
}
x <- seq(1,10,0.01)
x_app <- sapply(x,f)
plot(x, x_app, main = "Target function")

set.seed(42)

metropolis_normal <- function(n_iter = 10000, start = 1, proposal_sd = 0.1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rnorm(1, mean = x[t - 1], sd = proposal_sd)
    
    # f undefined for x <= 0
    if (proposal > 0) { 
      rate <- min(1, f(proposal) / f(x[t - 1]))
      if (runif(1) < rate) {
        x[t] <- proposal
        accept <- accept + 1
      } else {
        x[t] <- x[t - 1]
      }
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  return(list(chain = x, acceptance_rate = accept / n_iter))
}

result_a <- metropolis_normal(n_iter=10000)
samples_a <- result_a$chain
acceptance_rate_a <- result_a$acceptance_rate
plot(samples_a, type = "l", main = "Trace Plot (Part a)", xlab = "Iteration", ylab = "X_t")
hist(samples_a, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part a)", xlab = "X_t")

metropolis_chisq <- function(n_iter = 10000, start = 1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rchisq(1, floor(x[t - 1] + 1))
    rate <- min(1, f(proposal) / f(x[t - 1]))
    if (runif(1) < rate) {
      x[t] <- proposal
      accept <- accept + 1
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  list(samples = x, acceptance_rate = accept / n_iter)
}

result_b <- metropolis_chisq()
samples_b <- result_b$samples
acceptance_rate_b <- result_b$acceptance_rate

plot(samples_b, type = "l", main = "Trace Plot (Part b)", xlab = "Iteration", ylab = "X_t")
hist(samples_b, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part b)", xlab = "X_t")

metropolis_gamma <- function(n_iter = 10000, start = 1, alpha = 3, beta = 1) {
  x <- numeric(n_iter)
  x[1] <- start
  accept <- 0
  
  for (t in 2:n_iter) {
    proposal <- rgamma(1, shape = alpha, rate = beta)
    rate <- min(1, f(proposal) / f(x[t - 1]))
    if (runif(1) < rate) {
      x[t] <- proposal
      accept <- accept + 1
    } else {
      x[t] <- x[t - 1]
    }
  }
  
  list(samples = x, acceptance_rate = accept / n_iter)
}

result_c <- metropolis_gamma()
samples_c <- result_c$samples
acceptance_rate_c <- result_c$acceptance_rate

plot(samples_c, type = "l", main = "Trace Plot (Part c)", xlab = "Iteration", ylab = "X_t")
hist(samples_c, probability = TRUE, breaks = 50, main = "Histogram of Samples (Part c)", xlab = "X_t")



estimate_expectation <- function(samples) {
  mean(samples)
}

cat("Estimated E(X) (Part a):", estimate_expectation(samples_a), "\n")
cat("Estimated E(X) (Part b):", estimate_expectation(samples_b), "\n")
cat("Estimated E(X) (Part c):", estimate_expectation(samples_c), "\n")
```